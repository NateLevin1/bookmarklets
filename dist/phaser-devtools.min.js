if(console.log("Activated 🛟 Phaser Devtools bookmarklet."),!window.Phaser)throw new Error("This page does not expose any Phaser object :(");if(!window.Phaser.Renderer.WebGL.Pipelines.PostFXPipeline)throw new Error("This Phaser game is too outdated! Must be on Phaser >3.5, this game is running "+Phaser.VERSION);if(window.__phaser_devtools_injected)throw new Error("Phaser DevTools are already injected into this page.");window.__phaser_devtools_injected=!0;let oldPush=Array.prototype.push,game;function startDevTools(e){console.log("%cStarting Phaser DevTools...","color: gray"),e.scene.add("__phaser-devtools",PhaserDevTools,!0)}Array.prototype.push=function(...arguments){return(this[0]?.scene||this[0]?.gameObject?.scene)&&(game=this[0]?.scene?.game??this[0].gameObject.scene.game,window.phaserGame=game,console.log("%cSuccessfully found Phaser game!","color: green"),console.log("%cRunning Phaser DevTools v0.1.0, Phaser v"+Phaser.VERSION,"color: rebeccapurple"),Array.prototype.push=oldPush,startDevTools(game)),oldPush.call(this,...arguments)};class PhaserDevTools extends Phaser.Scene{enabled=!1;constructor(){super()}preload(){}create(){this.sys.game.device.os.desktop||alert('Please note that Phaser DevTools is not optimized for use on non-desktop browsers. Press "OK" to continue.'),game.domContainer||(game.domContainer=document.createElement("div"),game.domContainer.style.cssText=["display: block;","width: "+game.canvas.clientWidth+"px;","height: "+game.canvas.clientHeight+"px;","padding: 0;","margin: 0;",`margin-top: ${game.canvas.style.marginTop};`,`margin-left: ${game.canvas.style.marginLeft};`,"position: absolute;","overflow: hidden;","pointer-events: "+game.config.domPointerEvents+";","transform: scale(1);","transform-origin: left top;"].join(" "),document.body.prepend(game.domContainer),document.body.style.overflow="hidden",document.body.style.width="100%",document.body.style.height="100%",game.scale.refresh());var e=document.createElement("button");e.onclick=()=>{this.enabled=!this.enabled},this.add.dom(50,50,e,"background-color: rgba(50,0,50, 0.5); width: 70px; height: 70px; border-radius: 99999px; backdrop-filter: blur(10px); filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.5)); border: none; outline: none; cursor: pointer;"),this.sys.game.renderer.pipelines.addPostPipeline(HoverPipeline.KEY,HoverPipeline),console.log("%c⭐️🧑‍💻 Phaser DevTools loaded successfully!","color: green; font-size: 1.2em; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif")}update(e,o){this.enabled&&this.loadAllGameObjects()}loadAllGameObjects(){this.forAllGameObjects(e=>{!e.getData("__phaser_devtools_loaded")&&e.active&&(e.setData("__phaser_devtools_loaded",!0),e.setInteractive(),e.on("pointerover",()=>{this.enabled&&e.setPostPipeline&&!isBackgroundItem(e,this.sys)&&e.setPostPipeline(HoverPipeline.KEY)}),e.on("pointerout",()=>{this.enabled&&e.resetPostPipeline&&!isBackgroundItem(e,this.sys)&&e.resetPostPipeline()}))})}forAllGameObjects(o){this.getActiveScenes().forEach(e=>e.children.list.forEach(o))}getActiveScenes(){return game.scene.getScenes(!0).filter(e=>!(e instanceof PhaserDevTools))}}class HoverPipeline extends Phaser.Renderer.WebGL.Pipelines.PostFXPipeline{static KEY="__phaser_devtools_hover";constructor(e){super({game:e,renderer:e.renderer,fragShader:`
        #define SHADER_NAME PHASER_DEVTOOLS_HOVER
        precision mediump float;
        uniform sampler2D uMainSampler;
        uniform vec2 uTextureSize;
        varying vec2 outTexCoord;
        uniform float time;
        // seconds between rainbows
        float rainbowSpeed = 3.0;
        // see https://www.shadertoy.com/view/lsfBWs
        vec3 rainbow(float level) {
            float r = float(level <= 2.0) + float(level > 4.0) * 1.0;
            float g = max(1.0 - abs(level - 2.0) * 0.4, 0.0);
            float b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);
            return vec3(r, g, b);
        }
        vec4 smoothRainbow(float x)
        {
            float level1 = floor(x*6.0);
            float level2 = min(6.0, floor(x*6.0) + 1.0);
            
            vec3 a = rainbow(level1);
            vec3 b = rainbow(level2);
            
            return vec4(mix(a, b, fract(x*6.0)), 1);
        }
        void main(void) 
        {
            vec4 texture = texture2D(uMainSampler, outTexCoord);
            vec4 color = texture;
            float level = (1.0 / rainbowSpeed) * mod(time, rainbowSpeed);
            color = smoothRainbow(level);
            // edge detection
            float surroundingAlphaSum =
                texture2D(uMainSampler, outTexCoord + vec2(-0.0001, -0.0001)).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0,      -0.0001)).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0,       -0.002)).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0.0001, -0.0001)).a + 
                texture2D(uMainSampler, outTexCoord + vec2(-0.0001,  0     )).a + 
                texture2D(uMainSampler, outTexCoord + vec2( -0.001,  0     )).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0.0001,  0     )).a + 
                texture2D(uMainSampler, outTexCoord + vec2(  0.001,  0     )).a + 
                texture2D(uMainSampler, outTexCoord + vec2(-0.0001,  0.0001)).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0,       0.0001)).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0,        0.002)).a + 
                texture2D(uMainSampler, outTexCoord + vec2( 0.0001,  0.0001)).a;
            
            if(texture.a == 0.0 && surroundingAlphaSum > 0.0) {
                // outline
                gl_FragColor = vec4(0.85,0.85,0.85,1) + color * 0.15;
            } else if(texture.a > 0.1) {
                // rainbow inside
                gl_FragColor = texture * 0.85 + color * 0.15;
            } else {
                // everything else
                gl_FragColor = texture;
            }
        }
      `})}onRender(e,o){this.set1f("time",e.time.now/1e3)}}function isBackgroundItem(e,o){return e?.displayWidth>o.scale.width||e?.displayHeight>o.scale.height}